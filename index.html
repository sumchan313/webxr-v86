<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Google Cardboard VR Cube Grab</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #video {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    let scene, cube, renderer;
    let leftCamera, rightCamera;
    let isGrabbing = false;

    window.addEventListener('DOMContentLoaded', () => {
      // Scene setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020);

      const aspect = window.innerWidth / 2 / window.innerHeight;
      leftCamera = new THREE.PerspectiveCamera(70, aspect, 0.01, 100);
      rightCamera = new THREE.PerspectiveCamera(70, aspect, 0.01, 100);
      leftCamera.position.z = 2;
      rightCamera.position.z = 2;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Cube
      cube = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.2, 0.2),
        new THREE.MeshNormalMaterial()
      );
      cube.position.set(0, 0, -0.5);
      scene.add(cube);

      // Render loop: split screen
      function renderStereo() {
        renderer.setScissorTest(true);

        // Left eye
        renderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight);
        renderer.setScissor(0, 0, window.innerWidth / 2, window.innerHeight);
        renderer.render(scene, leftCamera);

        // Right eye
        renderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
        renderer.setScissor(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
        renderer.render(scene, rightCamera);

        renderer.setScissorTest(false);
        requestAnimationFrame(renderStereo);
      }
      renderStereo();

      // Camera feed for MediaPipe
      const video = document.getElementById('video');
      navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" }
      }).then(stream => {
        video.srcObject = stream;
        console.log("✅ Camera stream started");
      }).catch(err => {
        console.error("❌ Camera access failed:", err);
      });

      // MediaPipe Hands
      const hands = new Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      });

      hands.onResults(results => {
        if (results.multiHandLandmarks.length > 0) {
          const landmarks = results.multiHandLandmarks[0];
          const indexTip = landmarks[8];
          const thumbTip = landmarks[4];

          const pinchDistance = Math.hypot(
            indexTip.x - thumbTip.x,
            indexTip.y - thumbTip.y
          );

          const x = (indexTip.x - 0.5) * 2;
          const y = -(indexTip.y - 0.5) * 2;
          const z = -0.5;

          const pinchThreshold = 0.05;

          if (pinchDistance < pinchThreshold) {
            isGrabbing = true;
            cube.position.set(x, y, z);
          } else {
            isGrabbing = false;
          }
        }
      });

      const cameraFeed = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 640,
        height: 480
      });
      cameraFeed.start();
    });
  </script>
</body>
</html>
